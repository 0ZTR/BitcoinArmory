--- src/gui/kernel/qeventdispatcher_mac.mm	2014-08-02 14:07:52.000000000 -0400
+++ src/gui/kernel/qeventdispatcher_mac.mm	2014-08-04 17:33:23.000000000 -0400
@@ -600,8 +600,29 @@
             // [NSApp run], which is the normal code path for cocoa applications.
             if (NSModalSession session = d->currentModalSession()) {
                 QBoolBlocker execGuard(d->currentExecIsNSAppRun, false);
-                while ([NSApp runModalSession:session] == NSRunContinuesResponse && !d->interrupt)
-                    qt_mac_waitForMoreModalSessionEvents();
+
+                // OSX 10.9 appears to tighten up its internal code such that
+                // sessions shouldn't be used once they've been freed, which
+                // could happen in the else condition of the if(canExec)
+                // statement. Add extra logic to make sure we don't use the
+                // session once the current modal session is freed.
+                bool stayInLoop = true;
+                while (!d->interrupt && stayInLoop) {
+                    if([NSApp runModalSession:session] == NSRunContinuesResponse) {
+                        qt_mac_waitForMoreModalSessionEvents();
+
+            			// Check current session instead of our copy, otherwise
+            			// we'll go back to runModalSession and get a warning.
+            			// Also, temporarilyStopAllModalSessions() will get an
+            			// unnecessary hit if we overwrite the session var.
+            			if(d->currentModalSession() == 0) {
+                            stayInLoop = false;
+                        }
+                    }
+                    else {
+                        stayInLoop = false;
+                    }
+                }
 
                 if (!d->interrupt && session == d->currentModalSessionCached) {
                     // Someone called [NSApp stopModal:] from outside the event
@@ -835,6 +856,7 @@
         if (info.session) {
             [NSApp endModalSession:info.session];
             info.session = 0;
+            [(NSWindow*) info.nswindow release];
         }
     }
     currentModalSessionCached = 0;
@@ -935,12 +957,14 @@
             currentModalSessionCached = info.session;
             break;
         }
-        cocoaModalSessionStack.remove(i);
         currentModalSessionCached = 0;
         if (info.session) {
+            Q_ASSERT(info.nswindow != 0);
             [NSApp endModalSession:info.session];
             [(NSWindow *)info.nswindow release];
         }
+        // remove the info now that we are finished with it
+        cocoaModalSessionStack.remove(i);
     }
 
     updateChildrenWorksWhenModal();
@@ -949,6 +973,8 @@
 
 void QEventDispatcherMacPrivate::beginModalSession(QWidget *widget)
 {
+    QEventDispatcherMac::instance()->interrupt();
+
     // Add a new, empty (null), NSModalSession to the stack.
     // It will become active the next time QEventDispatcher::processEvents is called.
     // A QCocoaModalSessionInfo is considered pending to become active if the widget pointer 
@@ -970,16 +996,19 @@
     // when we stop the _current_ modal session (which is the session on top of
     // the stack, and might not belong to 'widget'). 
     int stackSize = cocoaModalSessionStack.size();
+    int endedSessions = 0;
     for (int i=stackSize-1; i>=0; --i) {
         QCocoaModalSessionInfo &info = cocoaModalSessionStack[i];
+        if (!info.widget)
+            endedSessions++;
         if (info.widget == widget) {
             info.widget = 0;
-            if (i == stackSize-1) {
+            if (i + endedSessions == stackSize-1) {
                 // The top sessions ended. Interrupt the event dispatcher
                 // to start spinning the correct session immidiatly: 
+                QEventDispatcherMac::instance()->interrupt();
                 currentModalSessionCached = 0;
                 cleanupModalSessionsNeeded = true;
-                QEventDispatcherMac::instance()->interrupt();
             }
         }
     }
